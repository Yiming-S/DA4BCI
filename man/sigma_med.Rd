% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/utils.R
\name{sigma_med}
\alias{sigma_med}
\title{Robust Median‑Distance Estimator}
\usage{
sigma_med(X, Y, m = 400, seed = NULL)
}
\arguments{
\item{X}{A numeric matrix (\eqn{n_1 \times p}) whose rows are observations
and columns are features (e.g., source or training domain).}

\item{Y}{A numeric matrix (\eqn{n_2 \times p}) with the same number of
columns as \code{X} (e.g., target or test domain).}

\item{m}{An integer giving the maximum number of rows used to estimate the
median distance.  If \code{nrow(rbind(X, Y)) > m}, rows are sampled
uniformly without replacement; otherwise all rows are used.}

\item{seed}{Optional integer.  When supplied, the random subsample is
reproducible via \code{\link[base]{set.seed}}.}
}
\value{
A positive numeric scalar—the median Euclidean distance between
rows of \code{X} and \code{Y}.  Returns \code{NA_real_} if the sample
size is insufficient.
}
\description{
The \code{sigma_med} function implements the so‑called \emph{median
heuristic} for selecting the bandwidth \eqn{\sigma} used in RBF (Gaussian)
kernels or Maximum Mean Discrepancy (MMD) tests.
It concatenates two data matrices \code{X} and \code{Y}, optionally
subsamples at most \code{m} rows for efficiency, computes all pairwise
Euclidean distances, and returns their median.  The routine is robust to
very small sample sizes and to duplicated observations.
}
\details{
\itemize{
\item When the combined sample size \eqn{N = n_1 + n_2} is \eqn{\le 2},
pairwise distances cannot be formed; the function returns
\code{NA_real_} and issues a warning.
\item If the median distance evaluates to zero (e.g., many duplicate
rows), a machine‑epsilon positive constant is returned instead to
avoid divide‑by‑zero errors in subsequent computations of
\eqn{1/(2\sigma^2)}.
}
}
\examples{
set.seed(42)
X <- matrix(rnorm(100), nrow = 20)
Y <- matrix(rnorm(120, 2), nrow = 20)

# Use all rows (N <= m)
sigma_all <- sigma_med(X, Y)

# Subsample at most 15 rows
sigma_sub <- sigma_med(X, Y, m = 15, seed = 1)

}
