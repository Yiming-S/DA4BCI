}
# ---------------------------------------------
# Parallel Domain Adaptation Testing Script
# ---------------------------------------------
library(DA4BCI)
ls("package:DA4BCI")
install.packages("remotes")
remotes::install_github("Yiming-S/DA4BCI")
# ---------------------------------------------
# Parallel Domain Adaptation Testing Script
# ---------------------------------------------
library(DA4BCI)
ls("package:DA4BCI")
# Required Libraries
library(parallel)
library(doParallel)
library(foreach)
library(ggplot2)
library(gridExtra)
library(Rtsne)
library(RSpectra)
library(geigen)
library(MASS)
# Path for Saving Results
pic_dir <- "~/Desktop/pic"  # Adjust as needed
# Domain Adaptation Methods
DA_methods <- c("tca", "sa", "mida", "rd", "coral", "gfk")
# ---------------------------------------------
# (1) Generate Data
# ---------------------------------------------
generate_data <- function(n_s, n_t, dist_type, fs = 160, t = 3) {
adj_n_s <- n_s * fs * t
adj_n_t <- n_t * fs * t
dist_name <- switch(
as.character(dist_type),
"1" = "Standard Normal Distribution",
"2" = "Uniform Distribution",
"3" = "Normal Distribution (Different Means)",
"4" = "Exponential Distribution",
"5" = "Normal Dist (Different SD)",
"6" = "Poisson Distribution",
"7" = "Student's t-Distribution",
"8" = "Binomial Distribution",
"9" = "Normal Dist (Another Variant)",
"10" = "Normal + Cauchy Distribution",
stop("Invalid dist_type.")
)
source_data <- switch(
as.character(dist_type),
"1"  = matrix(rnorm(adj_n_s * 50), adj_n_s, 50),
"2"  = matrix(runif(adj_n_s * 50), adj_n_s, 50),
"3"  = matrix(rnorm(adj_n_s * 50, mean = 5), adj_n_s, 50),
"4"  = matrix(rexp(adj_n_s * 50), adj_n_s, 50),
"5"  = matrix(rnorm(adj_n_s * 50, sd = 2), adj_n_s, 50),
"6"  = matrix(rpois(adj_n_s * 50, lambda = 3), adj_n_s, 50),
"7"  = matrix(rt(adj_n_s * 50, df = 5), adj_n_s, 50),
"8"  = matrix(rbinom(adj_n_s * 50, size = 10, prob = 0.3), adj_n_s, 50),
"9"  = matrix(rnorm(adj_n_s * 50), adj_n_s, 50),
"10" = matrix(rnorm(adj_n_s * 50), adj_n_s, 50),
stop("Invalid dist_type.")
)
target_data <- switch(
as.character(dist_type),
"1"  = matrix(rnorm(adj_n_t * 50), adj_n_t, 50),
"2"  = matrix(runif(adj_n_t * 50), adj_n_t, 50),
"3"  = matrix(rnorm(adj_n_t * 50, mean = -5), adj_n_t, 50),
"4"  = matrix(rexp(adj_n_t * 50), adj_n_t, 50),
"5"  = matrix(rnorm(adj_n_t * 50, sd = 0.5), adj_n_t, 50),
"6"  = matrix(rpois(adj_n_t * 50, lambda = 10), adj_n_t, 50),
"7"  = matrix(rt(adj_n_t * 50, df = 10), adj_n_t, 50),
"8"  = matrix(rbinom(adj_n_t * 50, size = 10, prob = 0.7), adj_n_t, 50),
"9"  = matrix(rnorm(adj_n_t * 50, sd = 3), adj_n_t, 50),
"10" = matrix(rcauchy(adj_n_t * 50), adj_n_t, 50),
stop("Invalid dist_type.")
)
list(source_data = source_data, target_data = target_data, dist_name = dist_name)
}
# ---------------------------------------------
# (2) Parallel Testing
# ---------------------------------------------
# Initialize Parallel Cluster
cl <- makeCluster(detectCores() - 1)
registerDoParallel(cl)
# Collect Results
all_results <- list()
for (method_name in DA_methods) {
cat(">>> Testing method:", method_name, "\n")
results_this_method <- foreach(
i = 1:10,
.packages = c("ggplot2", "gridExtra", "Rtsne", "RSpectra", "geigen", "MASS")
) %dopar% {
# Generate test data
test_data <- generate_data(10, 10, dist_type = i, fs = 50, t = 10)
src <- test_data$source_data
tgt <- test_data$target_data
# Calculate MMD Before Adaptation
mmd_before <- compute_mmd(src, tgt, sigma = 1)
# Perform domain adaptation
start_time <- Sys.time()
da <- switch(
method_name,
tca = domain_adaptation_tca(src, tgt, k = 10, mu = 1e-5, sigma = 10),
sa  = domain_adaptation_sa(src, tgt, k = 10),
mida= domain_adaptation_mida(src, tgt, k = 10, max = TRUE),
rd  = {
rd_res <- domain_adaptation_riemannian(src, tgt)
list(weighted_source_data = src %*% rd_res$rotation_matrix, target_data = tgt)
},
coral = domain_adaptation_coral(src, tgt, lambda = 1e-5),
gfk   = domain_adaptation_gfk(src, tgt, dim_subspace = 10)
)
elapsed <- Sys.time() - start_time
# Visualization
Z_s <- da$weighted_source_data
Z_t <- da$target_data
# Calculate MMD After Adaptation
mmd_after <- compute_mmd(Z_s, Z_t, sigma = 1)
pdf(NULL)
plots <- plot_data_comparison(src, tgt, Z_s, Z_t, description = test_data$dist_name)
combined_plot <- grid.arrange(plots$p1, plots$p2, ncol = 2,
top = paste("Method:", method_name, "| DistType:", i))
dev.off()
# Save plot
ggsave(file.path(pic_dir, paste0(method_name, "_dist_", i, ".png")),
combined_plot, width = 14, height = 7)
# Return results for this distribution
data.frame(
Method = method_name, DistType = i,
MMD_Before = mmd_before, MMD_After = mmd_after,
Time_Taken = as.numeric(elapsed), stringsAsFactors = FALSE
)
}
summary_table <- rbind(summary_table, do.call(rbind, results_this_method))
}
# rbf_kernel
# compute_mmd
# orthonormal_complement
# plot_data_comparison
#####################################
#' RBF (Gaussian) Kernel Computation
#'
#' @description
#' The \code{rbf_kernel} function calculates the Radial Basis Function (RBF)
#' kernel matrix between two sets of observations \code{x} and \code{y},
#' using \eqn{\exp(-||x - y||^2 / \sigma^2)}. It returns only the cross-block
#' corresponding to \code{x} vs. \code{y}.
#'
#' @param x A numeric matrix where rows correspond to observations and columns
#'   to features.
#' @param y A numeric matrix with the same number of columns as \code{x}.
#' @param sigma A positive scalar for the RBF kernel bandwidth.
#'
#' @details
#' This function computes pairwise distances among rows of \code{x} and \code{y}
#' (stacked together) via \code{\link[stats]{dist}}, then transforms them using
#' the Gaussian kernel formula. Only the \code{x} vs. \code{y} sub-block is returned,
#' producing an \eqn{n_x \times n_y} matrix.
#'
#' @return A numeric matrix of size \eqn{nrow(x) \times nrow(y)} containing
#'   the RBF kernel values.
#'
#' @examples
#' \dontrun{
#' set.seed(123)
#' x <- matrix(rnorm(20), nrow = 5, ncol = 4)
#' y <- matrix(rnorm(24, mean = 2), nrow = 6, ncol = 4)
#' Kxy <- rbf_kernel(x, y, sigma = 1)
#' dim(Kxy)  # 5 x 6
#' }
#'
#' @export
#####################################
rbf_kernel <- function(x, y, sigma) {
distx <- as.matrix(dist(rbind(x, y)))
kernel <- exp(- (distx / sigma)^2)
n <- nrow(x)
return(kernel[1:n, -(1:n)])
}
#####################################
#' Compute the Maximum Mean Discrepancy (MMD)
#'
#' @description
#' The \code{compute_mmd} function estimates the squared MMD between a source
#' dataset and a target dataset, using an RBF kernel with bandwidth \code{sigma}.
#' MMD is often used to measure distribution discrepancy in domain adaptation.
#'
#' @param source A numeric matrix representing the source domain (rows = observations,
#'   columns = features).
#' @param target A numeric matrix representing the target domain, with the same
#'   number of columns as \code{source}.
#' @param sigma A positive scalar for the RBF kernel bandwidth.
#'
#' @details
#' The MMD is computed as:
#' \deqn{
#'   \mathrm{MMD}^2 = \frac{1}{m^2} \sum_{i,j} K_{ss}(i,j)
#'     + \frac{1}{n^2} \sum_{i,j} K_{tt}(i,j)
#'     - \frac{2}{mn} \sum_{i,j} K_{st}(i,j),
#' }
#' where \eqn{K_{ss}} is the RBF kernel among source samples, \eqn{K_{tt}} among
#' target samples, and \eqn{K_{st}} between source and target samples. This metric
#' reflects how different the distributions are.
#'
#' @return A single numeric value indicating the estimated squared MMD between
#'   \code{source} and \code{target}.
#'
#' @examples
#' \dontrun{
#' set.seed(123)
#' src <- matrix(rnorm(100), nrow = 20, ncol = 5)
#' tgt <- matrix(rnorm(100, mean = 2), nrow = 20, ncol = 5)
#' mmd_val <- compute_mmd(src, tgt, sigma = 1)
#' cat("MMD^2 =", mmd_val, "\n")
#' }
#'
#' @export
#####################################
compute_mmd <- function(source, target, sigma) {
Kss <- rbf_kernel(source, source, sigma)
Ktt <- rbf_kernel(target, target, sigma)
Kst <- rbf_kernel(source, target, sigma)
m <- nrow(source)
n <- nrow(target)
mmd <- sum(Kss) / (m * m) + sum(Ktt) / (n * n) - 2 * sum(Kst) / (m * n)
return(mmd)
}
#####################################
#' Orthonormal Complement of a Matrix
#'
#' @description
#' The \code{orthonormal_complement} function computes a matrix whose columns form
#' an orthonormal basis for the subspace orthogonal to \code{U} in \eqn{\mathbb{R}^d}.
#' Useful in methods like GFK, where one needs both the principal subspace and
#' its complement.
#'
#' @param U A \eqn{d \times k} matrix with orthonormal columns.
#'
#' @details
#' The function uses a QR decomposition of the \eqn{d \times d} identity matrix
#' to get a full orthonormal basis, then projects it onto the orthogonal complement
#' of \code{U}. Columns close to zero (norm < 1e-8) are removed. The result is truncated
#' to \eqn{d-k} columns if needed.
#'
#' @return A \eqn{d \times (d-k)} matrix (or fewer columns if some are removed),
#'   with orthonormal columns that are orthogonal to every column of \code{U}.
#'
#' @examples
#' \dontrun{
#' set.seed(123)
#' U <- qr.Q(qr(matrix(rnorm(12), nrow = 4, ncol = 3)))  # 4x3 orthonormal basis
#' U_perp <- orthonormal_complement(U)
#' dim(U_perp)  # should be 4 x 1
#' # Check orthogonality: crossprod(U, U_perp) ~ 0
#' }
#'
#' @export
#####################################
orthonormal_complement <- function(U) {
d <- nrow(U)
k <- ncol(U)
Q <- qr.Q(qr(diag(d)))
ProjU <- U %*% t(U)
for (i in seq_len(d)) {
qi <- Q[, i, drop = FALSE]
qi_orth <- qi - ProjU %*% qi
norm_qi <- sqrt(sum(qi_orth^2))
if (norm_qi > 1e-12) {
Q[, i] <- qi_orth[, 1] / norm_qi
} else {
Q[, i] <- 0
}
}
norms <- colSums(Q^2)
keep_idx <- which(norms > 1e-8)
U_perp <- Q[, keep_idx, drop = FALSE]
if (ncol(U_perp) > (d - k)) {
U_perp <- U_perp[, 1:(d - k), drop = FALSE]
}
return(U_perp)
}
#####################################
#' Visual Comparison of Data Before and After Domain Adaptation
#'
#' @description
#' The \code{plot_data_comparison} function provides a simple 2D visualization
#' comparing source and target data distributions \emph{before} and \emph{after}
#' a domain adaptation transform. It uses either PCA or t-SNE to reduce data to
#' two dimensions for plotting.
#'
#' @param source_data A numeric matrix of the source data (rows = observations),
#'   before adaptation.
#' @param target_data A numeric matrix of the target data, before adaptation,
#'   with the same number of columns as \code{source_data}.
#' @param Z_s (Optional) The source data after adaptation; if \code{NULL}, no
#'   "after" plot is generated.
#' @param Z_t (Optional) The target data after adaptation.
#' @param description A character string to annotate the plot titles.
#' @param method A character string indicating which dimensional reduction method
#'   to apply for visualization. Choices are \code{"pca"} (default) or \code{"tsne"}.
#'
#' @details
#' \enumerate{
#'   \item Merges \code{source_data} and \code{target_data}, applies either PCA
#'     (\code{\link[stats]{prcomp}}) or t-SNE (\code{\link[Rtsne]{Rtsne}}) to map
#'     them into 2D, then plots them as "Before."
#'   \item If \code{Z_s} and \code{Z_t} are provided, merges and plots them as "After"
#'     the adaptation transform.
#' }
#' This helps visually inspect how the adaptation influences the overlap or
#' separation of the source and target.
#'
#' @return A list containing:
#' \describe{
#'   \item{\code{p1}}{The \code{ggplot2} object for the "before" distribution.}
#'   \item{\code{p2}}{The \code{ggplot2} object for the "after" distribution
#'     (only returned if \code{Z_s} and \code{Z_t} are not \code{NULL}).}
#' }
#'
#' @examples
#' \dontrun{
#' library(ggplot2)
#' set.seed(123)
#' src <- matrix(rnorm(100), nrow=20, ncol=5)
#' tgt <- matrix(rnorm(100, mean=3), nrow=20, ncol=5)
#'
#' # Plot only "before"
#' p_list <- plot_data_comparison(src, tgt, description = "NoAdapt", method = "pca")
#' print(p_list$p1)
#'
#' # Suppose Z_s and Z_t are aligned data
#' Z_s <- src + 1
#' Z_t <- tgt
#' p_list2 <- plot_data_comparison(src, tgt, Z_s, Z_t,
#'                                 description = "FakeAlign", method = "tsne")
#' print(p_list2$p1)
#' print(p_list2$p2)
#' }
#'
#' @export
#####################################
plot_data_comparison <- function(source_data, target_data,
Z_s = NULL, Z_t = NULL,
description = "NULL",
method = c("pca", "tsne")) {
method <- match.arg(method)
to_real <- function(data) {
if (is.complex(data)) Re(data) else data
}
source_data <- to_real(source_data)
target_data <- to_real(target_data)
if (!is.null(Z_s)) Z_s <- to_real(Z_s)
if (!is.null(Z_t)) Z_t <- to_real(Z_t)
data_before <- rbind(source_data, target_data)
labels_before <- c(rep("Source", nrow(source_data)),
rep("Target", nrow(target_data)))
pca_before <- switch(
method,
pca  = prcomp(data_before, rank. = 2)$x,
tsne = Rtsne::Rtsne(data_before)$Y
)
df_before <- data.frame(PC1 = pca_before[,1],
PC2 = pca_before[,2],
Label = labels_before)
p1 <- ggplot2::ggplot(df_before, ggplot2::aes(x = PC1, y = PC2, color = Label)) +
ggplot2::geom_point(alpha = 0.6) +
ggplot2::labs(title = paste0("Data Distribution Before ", description))
if (is.null(Z_s) || is.null(Z_t)) {
return(list(p1 = p1))
}
data_after <- rbind(Z_s, Z_t)
labels_after <- c(rep("Source", nrow(Z_s)), rep("Target", nrow(Z_t)))
pca_after <- switch(
method,
pca  = prcomp(data_after, rank. = 2)$x,
tsne = Rtsne::Rtsne(data_after)$Y
)
df_after <- data.frame(PC1 = pca_after[,1],
PC2 = pca_after[,2],
Label = labels_after)
p2 <- ggplot2::ggplot(df_after, ggplot2::aes(x = PC1, y = PC2, color = Label)) +
ggplot2::geom_point(alpha = 0.6) +
ggplot2::labs(title = paste0("Data Distribution After ", description))
list(p1 = p1, p2 = p2)
}
# install.packages("remotes")
remotes::install_github("Yiming-S/DA4BCI")
# ---------------------------------------------
# Parallel Domain Adaptation Testing Script
# ---------------------------------------------
library(DA4BCI)
ls("package:DA4BCI")
# Required Libraries
library(parallel)
library(doParallel)
library(foreach)
library(ggplot2)
library(gridExtra)
library(Rtsne)
library(RSpectra)
library(geigen)
library(MASS)
# Path for Saving Results
pic_dir <- "~/Desktop/pic"  # Adjust as needed
# Domain Adaptation Methods
DA_methods <- c("tca", "sa", "mida", "rd", "coral", "gfk")
# ---------------------------------------------
# (1) Generate Data
# ---------------------------------------------
generate_data <- function(n_s, n_t, dist_type, fs = 160, t = 3) {
adj_n_s <- n_s * fs * t
adj_n_t <- n_t * fs * t
dist_name <- switch(
as.character(dist_type),
"1" = "Standard Normal Distribution",
"2" = "Uniform Distribution",
"3" = "Normal Distribution (Different Means)",
"4" = "Exponential Distribution",
"5" = "Normal Dist (Different SD)",
"6" = "Poisson Distribution",
"7" = "Student's t-Distribution",
"8" = "Binomial Distribution",
"9" = "Normal Dist (Another Variant)",
"10" = "Normal + Cauchy Distribution",
stop("Invalid dist_type.")
)
source_data <- switch(
as.character(dist_type),
"1"  = matrix(rnorm(adj_n_s * 50), adj_n_s, 50),
"2"  = matrix(runif(adj_n_s * 50), adj_n_s, 50),
"3"  = matrix(rnorm(adj_n_s * 50, mean = 5), adj_n_s, 50),
"4"  = matrix(rexp(adj_n_s * 50), adj_n_s, 50),
"5"  = matrix(rnorm(adj_n_s * 50, sd = 2), adj_n_s, 50),
"6"  = matrix(rpois(adj_n_s * 50, lambda = 3), adj_n_s, 50),
"7"  = matrix(rt(adj_n_s * 50, df = 5), adj_n_s, 50),
"8"  = matrix(rbinom(adj_n_s * 50, size = 10, prob = 0.3), adj_n_s, 50),
"9"  = matrix(rnorm(adj_n_s * 50), adj_n_s, 50),
"10" = matrix(rnorm(adj_n_s * 50), adj_n_s, 50),
stop("Invalid dist_type.")
)
target_data <- switch(
as.character(dist_type),
"1"  = matrix(rnorm(adj_n_t * 50), adj_n_t, 50),
"2"  = matrix(runif(adj_n_t * 50), adj_n_t, 50),
"3"  = matrix(rnorm(adj_n_t * 50, mean = -5), adj_n_t, 50),
"4"  = matrix(rexp(adj_n_t * 50), adj_n_t, 50),
"5"  = matrix(rnorm(adj_n_t * 50, sd = 0.5), adj_n_t, 50),
"6"  = matrix(rpois(adj_n_t * 50, lambda = 10), adj_n_t, 50),
"7"  = matrix(rt(adj_n_t * 50, df = 10), adj_n_t, 50),
"8"  = matrix(rbinom(adj_n_t * 50, size = 10, prob = 0.7), adj_n_t, 50),
"9"  = matrix(rnorm(adj_n_t * 50, sd = 3), adj_n_t, 50),
"10" = matrix(rcauchy(adj_n_t * 50), adj_n_t, 50),
stop("Invalid dist_type.")
)
list(source_data = source_data, target_data = target_data, dist_name = dist_name)
}
# ---------------------------------------------
# (2) Parallel Testing
# ---------------------------------------------
# Initialize Parallel Cluster
cl <- makeCluster(detectCores() - 1)
registerDoParallel(cl)
# Collect Results
all_results <- list()
for (method_name in DA_methods) {
cat(">>> Testing method:", method_name, "\n")
results_this_method <- foreach(
i = 1:10,
.packages = c("ggplot2", "gridExtra", "Rtsne", "RSpectra", "geigen", "MASS")
) %dopar% {
# Generate test data
test_data <- generate_data(10, 10, dist_type = i, fs = 50, t = 10)
src <- test_data$source_data
tgt <- test_data$target_data
# Calculate MMD Before Adaptation
mmd_before <- compute_mmd(src, tgt, sigma = 1)
# Perform domain adaptation
start_time <- Sys.time()
da <- switch(
method_name,
tca = domain_adaptation_tca(src, tgt, k = 10, mu = 1e-5, sigma = 10),
sa  = domain_adaptation_sa(src, tgt, k = 10),
mida= domain_adaptation_mida(src, tgt, k = 10, max = TRUE),
rd  = {
rd_res <- domain_adaptation_riemannian(src, tgt)
list(weighted_source_data = src %*% rd_res$rotation_matrix, target_data = tgt)
},
coral = domain_adaptation_coral(src, tgt, lambda = 1e-5),
gfk   = domain_adaptation_gfk(src, tgt, dim_subspace = 10)
)
elapsed <- Sys.time() - start_time
# Visualization
Z_s <- da$weighted_source_data
Z_t <- da$target_data
# Calculate MMD After Adaptation
mmd_after <- compute_mmd(Z_s, Z_t, sigma = 1)
pdf(NULL)
plots <- plot_data_comparison(src, tgt, Z_s, Z_t, description = test_data$dist_name)
combined_plot <- grid.arrange(plots$p1, plots$p2, ncol = 2,
top = paste("Method:", method_name, "| DistType:", i))
dev.off()
# Save plot
ggsave(file.path(pic_dir, paste0(method_name, "_dist_", i, ".png")),
combined_plot, width = 14, height = 7)
# Return results for this distribution
data.frame(
Method = method_name, DistType = i,
MMD_Before = mmd_before, MMD_After = mmd_after,
Time_Taken = as.numeric(elapsed), stringsAsFactors = FALSE
)
}
summary_table <- rbind(summary_table, do.call(rbind, results_this_method))
}
